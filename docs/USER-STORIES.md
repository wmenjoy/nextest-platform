# 测试管理平台增强 - User Story 文档

**文档版本**: 1.0
**创建日期**: 2025-11-21
**产品负责人**: 测试平台团队

---

## 📋 目录

1. [Story 编写规范](#story-编写规范)
2. [Epic 1: 测试数据批量导入](#epic-1-测试数据批量导入)
3. [Epic 2: 工作流编排](#epic-2-工作流编排)
4. [Epic 3: Lua脚本支持](#epic-3-lua脚本支持)
5. [Epic 4: 模板系统](#epic-4-模板系统)
6. [Epic 5: 前端现代化](#epic-5-前端现代化)
7. [附录: Story 地图](#附录-story-地图)

---

## Story 编写规范

### Story 模板

```
作为 [用户角色]
我想要 [功能/操作]
以便于 [业务价值]

验收标准:
- [ ] 标准1
- [ ] 标准2
- [ ] 标准3

技术要点:
- 技术实现关键点
- 依赖关系
- 风险点

优先级: P0/P1/P2
估算: XS/S/M/L/XL (对应 1/2/3/5/8 人天)
```

### 优先级定义

- **P0 (Critical)**: 核心功能，必须有
- **P1 (High)**: 重要功能，应该有
- **P2 (Medium)**: 锦上添花，可以有
- **P3 (Low)**: 未来规划，暂不实施

### 估算标准

| 规模 | 人天 | 说明 |
|------|------|------|
| **XS** | 0.5-1 | 简单配置、UI调整 |
| **S** | 1-2 | 简单功能、单一模块 |
| **M** | 2-3 | 中等复杂度、多模块 |
| **L** | 3-5 | 复杂功能、跨层交互 |
| **XL** | 5-8 | 非常复杂、架构级变更 |

---

## Epic 1: 测试数据批量导入

**Epic 描述**: 支持从CSV、Excel、JSON、YAML等格式批量导入测试用例，解放手工创建的重复劳动。

**业务价值**: 测试创建效率从1个/分钟提升至100个/分钟（100倍提升）

**目标用户**: QA测试工程师、测试负责人

**发布版本**: v1.0 (Phase 1)

---

### Story 1.1: CSV 格式导入

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 QA测试工程师
我想要 从CSV文件批量导入测试用例
以便于 快速创建大量测试用例，节省手工录入时间
```

#### 验收标准

- [ ] 支持上传CSV文件（最大10MB）
- [ ] 自动识别CSV列（testId, name, type, method, path等）
- [ ] 验证CSV格式（必填字段、数据类型）
- [ ] 显示导入预览（前10条）
- [ ] 支持增量导入（不覆盖已存在的测试）
- [ ] 导入成功后显示统计信息（成功X条，失败Y条）
- [ ] 导入失败时提供详细错误报告（CSV格式）

#### CSV 格式示例

```csv
testId,groupId,name,type,method,path,assertions,tags
test-1,api-tests,获取用户列表,http,GET,/api/users,"[{""type"":""status_code"",""expected"":200}]","api,smoke"
test-2,api-tests,创建用户,http,POST,/api/users,"[{""type"":""status_code"",""expected"":201}]","api,critical"
```

#### 技术要点

- 使用Go标准库 `encoding/csv` 解析CSV
- 逐行验证，收集所有错误
- 使用事务批量插入数据库
- 错误报告以CSV格式返回（包含行号、错误原因）

#### 依赖

- 无

#### 风险

- CSV格式不统一（需要明确的模板）
- 大文件导入性能问题（需要分批处理）

---

### Story 1.2: Excel 格式导入

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 QA测试工程师
我想要 从Excel文件批量导入测试用例
以便于 利用Excel的编辑能力（公式、筛选、格式）准备测试数据
```

#### 验收标准

- [ ] 支持上传Excel文件 (.xlsx)（最大10MB）
- [ ] 支持多Sheet（每个Sheet一个测试分组）
- [ ] 自动识别表头（第一行）
- [ ] 支持单元格公式（如 `=CONCATENATE("test-", A2)`）
- [ ] 验证数据格式
- [ ] 显示导入预览（每个Sheet前5条）
- [ ] 导入统计（按Sheet统计）
- [ ] 错误报告（Sheet名、行号、错误）

#### Excel 格式示例

| testId | groupId | name | type | method | path | assertions | tags |
|--------|---------|------|------|--------|------|------------|------|
| test-1 | api-tests | 获取用户列表 | http | GET | /api/users | [{"type":"status_code","expected":200}] | api,smoke |

#### 技术要点

- 使用 `github.com/xuri/excelize/v2` 库解析Excel
- 支持公式计算
- 逐行验证，保留Sheet上下文
- Sheet并行处理（提高性能）

#### 依赖

- Story 1.1 (CSV导入) - 复用验证逻辑

---

### Story 1.3: JSON/YAML 格式导入

**优先级**: P1
**估算**: S (2天)

#### Story 描述

```
作为 自动化测试工程师
我想要 从JSON/YAML文件批量导入测试用例
以便于 将代码仓库中的测试定义导入系统，实现版本控制
```

#### 验收标准

- [ ] 支持JSON格式（数组或单个对象）
- [ ] 支持YAML格式
- [ ] JSON Schema验证
- [ ] 嵌套结构支持（如assertions、headers）
- [ ] 验证并导入
- [ ] 错误报告（JSON Path或YAML行号）

#### JSON 格式示例

```json
[
  {
    "testId": "test-1",
    "groupId": "api-tests",
    "name": "获取用户列表",
    "type": "http",
    "http": {
      "method": "GET",
      "path": "/api/users"
    },
    "assertions": [
      {"type": "status_code", "expected": 200}
    ],
    "tags": ["api", "smoke"]
  }
]
```

#### 技术要点

- 使用 `encoding/json` 和 `gopkg.in/yaml.v3`
- 定义JSON Schema验证规则
- 支持单个对象或数组

---

### Story 1.4: 导入策略选择

**优先级**: P0
**估算**: S (2天)

#### Story 描述

```
作为 QA测试工程师
我想要 选择导入策略（增量/覆盖/校验）
以便于 根据不同场景灵活控制导入行为
```

#### 验收标准

- [ ] 支持3种导入策略：
  - **增量**: 仅添加新测试，跳过已存在的testId
  - **覆盖**: 更新已存在的测试，添加新测试
  - **校验**: 仅验证不导入，生成验证报告
- [ ] 策略选择UI（单选按钮）
- [ ] 策略说明提示（Tooltip）
- [ ] 冲突提示（覆盖模式下显示将覆盖的测试数量）

#### UI 设计

```
导入策略: ○ 增量导入  ● 覆盖导入  ○ 仅校验
           ↑ 提示：仅添加新测试，跳过已存在的
```

#### 技术要点

- 增量: 使用 `INSERT IGNORE` 或检查存在性
- 覆盖: 使用 `UPSERT` (INSERT ... ON CONFLICT UPDATE)
- 校验: 不执行INSERT，仅返回验证结果

---

### Story 1.5: 导入进度与状态

**优先级**: P1
**估算**: S (2天)

#### Story 描述

```
作为 QA测试工程师
我想要 查看导入进度和实时状态
以便于 了解导入是否成功，出现问题及时中止
```

#### 验收标准

- [ ] 上传文件时显示进度条（0-100%）
- [ ] 验证阶段显示"验证中..."状态
- [ ] 导入阶段显示进度（已导入X/总数Y）
- [ ] 实时显示成功/失败统计
- [ ] 支持取消导入（正在导入的批次完成后停止）
- [ ] 完成后显示结果摘要

#### UI 设计

```
┌─────────────────────────────────────┐
│  导入中... 45%                      │
│  ████████████░░░░░░░░░░░░░░        │
│                                     │
│  已导入: 450 / 1000                 │
│  ✅ 成功: 420                       │
│  ❌ 失败: 30                        │
│                                     │
│  [取消导入]                         │
└─────────────────────────────────────┘
```

#### 技术要点

- 使用WebSocket实时推送进度
- 分批导入（每批100条）
- 支持中断标志位

---

### Story 1.6: 导入历史查询

**优先级**: P2
**估算**: S (2天)

#### Story 描述

```
作为 测试负责人
我想要 查看历史导入记录
以便于 追溯测试数据来源，审计导入操作
```

#### 验收标准

- [ ] 导入历史列表页
- [ ] 显示字段：时间、文件名、格式、总数、成功数、失败数、操作人
- [ ] 支持时间筛选（最近7天/30天/自定义）
- [ ] 点击查看详情（成功的testId列表、失败原因）
- [ ] 下载错误报告（CSV）

#### UI 设计

```
┌─────────────────────────────────────────────────────┐
│  导入历史                                           │
├─────────────────────────────────────────────────────┤
│  时间              文件名       格式  总数  成功 失败 │
│  2025-11-21 10:30  tests.csv   CSV   100   95   5   │
│  2025-11-20 15:20  data.xlsx   Excel 500   500  0   │
│  2025-11-19 09:10  api.json    JSON  50    48   2   │
└─────────────────────────────────────────────────────┘
```

---

## Epic 2: 工作流编排

**Epic 描述**: 支持定义多步骤测试工作流，步骤间数据传递、条件执行、错误处理。

**业务价值**: 支持复杂业务流程的端到端测试，覆盖真实用户旅程

**目标用户**: 自动化测试工程师、QA工程师

**发布版本**: v2.0 (Phase 2)

---

### Story 2.1: YAML 格式工作流定义

**优先级**: P0
**估算**: L (4天)

#### Story 描述

```
作为 自动化测试工程师
我想要 使用YAML格式定义工作流
以便于 清晰地描述多步骤测试流程，易于版本控制
```

#### 验收标准

- [ ] 定义YAML格式规范（schema）
- [ ] 支持基础字段：name, version, variables, steps
- [ ] 支持步骤字段：id, name, type, testId, dependsOn, input, output
- [ ] YAML语法验证
- [ ] 语法高亮编辑器（Monaco Editor）
- [ ] 实时语法检查（错误提示）
- [ ] 示例模板（5个常用场景）

#### YAML 示例

```yaml
workflow:
  name: "用户注册登录流程"
  version: "1.0"
  variables:
    baseUrl: "http://localhost:8080"

  steps:
    - id: register
      name: 注册用户
      testId: user-register
      output:
        userId: "response.data.id"

    - id: login
      name: 用户登录
      testId: user-login
      dependsOn: [register]
      input:
        userId: "${register.userId}"
      output:
        token: "response.data.token"
```

#### 技术要点

- 定义严格的YAML Schema（使用JSON Schema）
- 使用 `gopkg.in/yaml.v3` 解析
- 验证字段类型、必填项
- 循环依赖检测

---

### Story 2.2: 工作流依赖解析

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 自动化测试工程师
我想要 定义步骤间的依赖关系
以便于 确保步骤按正确顺序执行
```

#### 验收标准

- [ ] 支持 `dependsOn` 字段（步骤ID数组）
- [ ] 拓扑排序算法（DAG）
- [ ] 检测循环依赖（报错）
- [ ] 并行执行无依赖的步骤
- [ ] 依赖失败时跳过后续步骤

#### 依赖示例

```yaml
steps:
  - id: A
  - id: B
    dependsOn: [A]
  - id: C
    dependsOn: [A]
  - id: D
    dependsOn: [B, C]

执行顺序: A → (B, C 并行) → D
```

#### 技术要点

- 实现拓扑排序算法（Kahn算法或DFS）
- 使用Goroutine并行执行独立步骤
- 使用sync.WaitGroup等待并行步骤完成

---

### Story 2.3: 变量传递与替换

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 自动化测试工程师
我想要 在步骤间传递数据（如用户ID、认证token）
以便于 后续步骤使用前面步骤的输出
```

#### 验收标准

- [ ] 支持全局变量（workflow.variables）
- [ ] 支持步骤输出（output）
- [ ] 支持步骤输入（input）
- [ ] 变量替换语法：`${variableName}` 或 `${stepId.outputName}`
- [ ] JSONPath提取：`response.data.id`
- [ ] 未定义变量报错

#### 变量示例

```yaml
# 全局变量
variables:
  baseUrl: "http://localhost:8080"

steps:
  - id: create-user
    output:
      userId: "response.data.id"  # JSONPath提取

  - id: get-user
    input:
      id: "${create-user.userId}"  # 引用前面步骤的输出
    http:
      path: "${baseUrl}/users/${create-user.userId}"
```

#### 技术要点

- 使用正则表达式匹配 `${...}`
- 实现JSONPath提取器（使用 `github.com/tidwall/gjson`）
- 变量作用域管理（全局、步骤级）

---

### Story 2.4: 条件执行

**优先级**: P1
**估算**: M (3天)

#### Story 描述

```
作为 自动化测试工程师
我想要 根据条件决定是否执行某个步骤
以便于 实现分支逻辑（如：仅在生产环境执行某步骤）
```

#### 验收标准

- [ ] 支持 `when` 字段（条件表达式）
- [ ] 条件语法：`${variable} == value`、`${variable} != value`
- [ ] 支持逻辑运算：`&&`、`||`、`!`
- [ ] 条件为false时跳过步骤
- [ ] 日志记录跳过原因

#### 条件示例

```yaml
steps:
  - id: create-order
    when: "${env} == 'production'"  # 仅在生产环境执行

  - id: send-email
    when: "${create-order.status} == 'success' && ${user.email} != ''"
```

#### 技术要点

- 实现简单的表达式求值器
- 或使用表达式库（如 `github.com/antonmedv/expr`）

---

### Story 2.5: 错误处理策略

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 自动化测试工程师
我想要 定义步骤失败时的处理策略
以便于 控制工作流是中止、继续还是重试
```

#### 验收标准

- [ ] 支持 `onError` 字段：`abort`（中止）、`continue`（继续）、`retry`（重试）
- [ ] `abort`: 立即中止工作流
- [ ] `continue`: 记录错误，继续执行后续步骤
- [ ] `retry`: 重试N次，失败后按`onError`处理
- [ ] 支持重试配置：`maxAttempts`、`backoff`（延迟策略）

#### 错误处理示例

```yaml
steps:
  - id: api-call
    onError: retry
    retry:
      maxAttempts: 3
      backoff: exponential  # 1s, 2s, 4s

  - id: cleanup
    onError: continue  # 清理失败不影响整体
```

#### 技术要点

- 实现重试逻辑（exponential backoff）
- 错误日志记录
- 错误传播控制

---

### Story 2.6: 工作流执行引擎

**优先级**: P0
**估算**: L (5天)

#### Story 描述

```
作为 系统后端
我需要 实现工作流执行引擎
以便于 按定义执行工作流
```

#### 验收标准

- [ ] 解析工作流YAML
- [ ] 拓扑排序确定执行顺序
- [ ] 初始化上下文（变量、步骤结果）
- [ ] 顺序/并行执行步骤
- [ ] 变量替换
- [ ] 错误处理
- [ ] 生成执行报告（状态、耗时、错误）

#### 技术要点

- 核心引擎 `WorkflowEngine`
- 上下文管理 `WorkflowContext`
- 步骤执行器 `StepExecutor`
- 结果收集器 `ResultCollector`

---

### Story 2.7: 工作流API

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 前端开发者
我需要 工作流管理API
以便于 实现工作流的CRUD和执行
```

#### 验收标准

- [ ] `POST /api/v2/workflows` - 创建工作流
- [ ] `GET /api/v2/workflows` - 列出工作流
- [ ] `GET /api/v2/workflows/:id` - 获取工作流详情
- [ ] `PUT /api/v2/workflows/:id` - 更新工作流
- [ ] `DELETE /api/v2/workflows/:id` - 删除工作流
- [ ] `POST /api/v2/workflows/:id/execute` - 执行工作流
- [ ] `GET /api/v2/workflows/:id/runs` - 执行历史
- [ ] `GET /api/v2/workflow-runs/:runId` - 执行详情

#### API 示例

```bash
# 创建工作流
POST /api/v2/workflows
{
  "name": "用户注册流程",
  "definition": "<YAML内容>"
}

# 执行工作流
POST /api/v2/workflows/wf-001/execute
{
  "variables": {
    "env": "test"
  }
}
```

---

### Story 2.8: 工作流列表与详情页

**优先级**: P0
**估算**: S (2天)

#### Story 描述

```
作为 QA测试工程师
我想要 浏览和管理工作流
以便于 找到需要的工作流并执行
```

#### 验收标准

- [ ] 工作流列表页（名称、版本、步骤数、最后执行时间）
- [ ] 搜索和筛选（按名称、标签）
- [ ] 查看工作流详情（YAML、步骤列表）
- [ ] 执行按钮（跳转到执行页）
- [ ] 编辑/删除按钮

#### UI 设计

```
┌─────────────────────────────────────────────────┐
│  工作流列表           [搜索...]  [新建工作流]   │
├─────────────────────────────────────────────────┤
│  名称              版本  步骤  最后执行    操作  │
│  用户注册流程      1.0   3    2小时前     执行  │
│  订单支付流程      2.1   5    1天前       执行  │
│  数据清理流程      1.0   2    未执行      执行  │
└─────────────────────────────────────────────────┘
```

---

### Story 2.9: 工作流执行监控页

**优先级**: P1
**估算**: M (3天)

#### Story 描述

```
作为 QA测试工程师
我想要 实时查看工作流执行状态
以便于 了解当前执行到哪一步，是否有错误
```

#### 验收标准

- [ ] 执行状态总览（运行中/成功/失败）
- [ ] 步骤列表（每个步骤的状态、耗时）
- [ ] 实时更新（WebSocket）
- [ ] 当前执行步骤高亮
- [ ] 失败步骤显示错误信息
- [ ] 取消执行按钮

#### UI 设计

```
┌─────────────────────────────────────────┐
│  工作流执行 - 用户注册流程              │
│  状态: ⏳ 运行中  已执行: 2/5           │
├─────────────────────────────────────────┤
│  ✅ 1. 注册用户       (200ms)           │
│  ✅ 2. 用户登录       (150ms)           │
│  ⏳ 3. 创建订单       (执行中...)       │
│  ⏸️  4. 支付订单       (等待中)         │
│  ⏸️  5. 清理数据       (等待中)         │
│                                         │
│  [取消执行]                             │
└─────────────────────────────────────────┘
```

---

### Story 2.10: 工作流实时数据流追踪

**优先级**: P0
**估算**: L (4天)

#### Story 描述

```
作为 自动化测试工程师
我想要 实时查看工作流执行过程中的数据流向
以便于 了解数据在步骤间如何传递和变化
```

#### 验收标准

- [ ] 步骤执行记录表（workflow_step_executions）
- [ ] 记录每个步骤的输入数据快照（input_data JSONB）
- [ ] 记录每个步骤的输出数据快照（output_data JSONB）
- [ ] WebSocket推送步骤完成事件（包含输入/输出数据）
- [ ] UI显示步骤的输入/输出数据
- [ ] 支持JSON格式化显示
- [ ] 支持数据折叠/展开

#### UI 设计

```
┌─────────────────────────────────────────┐
│  步骤详情 - 用户登录                    │
├─────────────────────────────────────────┤
│  状态: ✅ 成功  耗时: 150ms             │
│                                         │
│  输入数据:                              │
│  ┌───────────────────────────────────┐ │
│  │ {                                 │ │
│  │   "userId": 123,                  │ │
│  │   "username": "test_user"         │ │
│  │ }                                 │ │
│  └───────────────────────────────────┘ │
│                                         │
│  输出数据:                              │
│  ┌───────────────────────────────────┐ │
│  │ {                                 │ │
│  │   "token": "eyJhbGc...",          │ │
│  │   "expiresAt": "2025-11-22"       │ │
│  │ }                                 │ │
│  └───────────────────────────────────┘ │
│                                         │
│  [复制JSON] [下载]                      │
└─────────────────────────────────────────┘
```

#### 技术要点

- 在executeStep中捕获输入数据（从上下文变量和前序步骤输出构建）
- 在Action执行完成后捕获输出数据
- JSONB类型存储，支持高效查询
- WebSocket事件中包含context字段（当前变量快照）

---

### Story 2.11: 变量监控与历史追踪

**优先级**: P1
**估算**: M (3天)

#### Story 描述

```
作为 自动化测试工程师
我想要 查看工作流执行过程中变量的变化历史
以便于 调试问题和理解数据流
```

#### 验收标准

- [ ] 变量变更历史表（workflow_variable_changes）
- [ ] 记录变量的创建、更新、删除操作
- [ ] 记录变更前后的值（old_value, new_value）
- [ ] 关联触发变更的步骤（step_id）
- [ ] UI显示变量列表及当前值
- [ ] 点击变量查看变更历史
- [ ] 支持变更时间线视图

#### UI 设计

```
┌─────────────────────────────────────────────────┐
│  变量监控面板                                   │
├─────────────────────────────────────────────────┤
│  当前变量:                                      │
│  ┌───────────────────────────────────────────┐ │
│  │ baseUrl: "http://localhost:8080"          │ │
│  │ userId: 123  ← 步骤1输出 [查看历史]       │ │
│  │ token: "eyJ..."  ← 步骤2输出 [查看历史]  │ │
│  │ orderId: 456  ← 步骤3输出 [查看历史]     │ │
│  └───────────────────────────────────────────┘ │
│                                                 │
│  变量 "userId" 变更历史:                        │
│  ┌───────────────────────────────────────────┐ │
│  │ 10:30:01  创建    null → 123  (步骤1)    │ │
│  └───────────────────────────────────────────┘ │
└─────────────────────────────────────────────────┘
```

#### 技术要点

- 在输出映射时记录变量变更
- 比较新旧值，避免记录无变化的更新
- 支持复杂类型（对象、数组）的变更追踪
- 提供API查询变量历史

---

### Story 2.12: 步骤日志收集与查询

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 自动化测试工程师
我想要 查看每个步骤的详细执行日志
以便于 诊断问题和了解执行细节
```

#### 验收标准

- [ ] 步骤日志表（workflow_step_logs）
- [ ] 支持日志级别（debug, info, warn, error）
- [ ] LogCollector集成到ActionContext
- [ ] 所有内置Action输出关键日志
- [ ] WebSocket实时推送日志
- [ ] UI显示实时日志流
- [ ] 支持日志级别筛选
- [ ] 支持日志搜索

#### UI 设计

```
┌─────────────────────────────────────────────────┐
│  实时日志                      [级别: 全部 ▼]   │
├─────────────────────────────────────────────────┤
│  [10:30:01.123] [INFO] [register] 开始注册用户  │
│  [10:30:01.125] [INFO] [register] 发送POST请求  │
│  [10:30:01.200] [INFO] [register] 响应200 OK    │
│  [10:30:01.201] [INFO] [register] 用户创建成功  │
│  [10:30:02.001] [INFO] [login] 开始用户登录     │
│  [10:30:02.005] [INFO] [login] 发送POST请求     │
│  [10:30:02.150] [INFO] [login] 响应200 OK       │
│  [10:30:02.151] [INFO] [login] 获取token成功    │
│  [10:30:03.001] [INFO] [create-order] 创建订单  │
│  [10:30:03.005] [ERROR] [create-order] 库存不足 │
│                                                 │
│  [清空] [导出] [搜索...]                        │
└─────────────────────────────────────────────────┘
```

#### 技术要点

- LogCollector注入到ActionContext
- 每个Action调用logger.Info/Error记录关键步骤
- 日志异步写入数据库（避免阻塞执行）
- WebSocket推送日志事件（type: "log"）

---

### Story 2.13: WebSocket实时推送服务

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 系统后端
我需要 实现WebSocket消息推送服务
以便于 实时推送工作流执行状态到前端
```

#### 验收标准

- [ ] WebSocketHub实现（管理连接和广播）
- [ ] 客户端注册/注销机制
- [ ] 按runID路由消息（只推送给订阅该runID的客户端）
- [ ] 支持多种事件类型（workflow_started, step_completed, log等）
- [ ] 连接断开自动清理
- [ ] 新连接时发送历史事件（已完成的步骤）
- [ ] WebSocket端点：GET /api/v2/workflows/runs/:runId/stream

#### API 示例

```javascript
// 前端连接WebSocket
const ws = new WebSocket('ws://localhost:8080/api/v2/workflows/runs/run-123/stream');

ws.onmessage = (event) => {
  const message = JSON.parse(event.data);

  switch (message.type) {
    case 'workflow_started':
      console.log('工作流启动', message.data);
      break;
    case 'step_completed':
      console.log('步骤完成', message.data);
      updateUI(message.context.variables);
      break;
    case 'log':
      appendLog(message.data);
      break;
  }
};
```

#### 技术要点

- 使用gorilla/websocket库
- Hub使用channel通信（register, unregister, broadcast）
- 按runID组织客户端连接（map[string]map[*websocket.Conn]bool）
- 执行引擎调用hub.Broadcast推送事件
- 连接时查询数据库发送历史事件

---

### Story 2.14: 工作流执行历史查询API

**优先级**: P1
**估算**: S (2天)

#### Story 描述

```
作为 测试工程师
我想要 查询工作流的历史执行记录
以便于 分析执行趋势和问题排查
```

#### 验收标准

- [ ] GET /api/v2/workflows/:workflowId/runs - 列出执行记录
- [ ] GET /api/v2/workflows/runs/:runId - 获取执行详情
- [ ] GET /api/v2/workflows/runs/:runId/steps - 获取步骤列表
- [ ] GET /api/v2/workflows/runs/:runId/logs - 获取日志
- [ ] GET /api/v2/workflows/runs/:runId/variables/history - 变量历史
- [ ] 支持分页、排序、筛选
- [ ] 支持按状态筛选（success, failed, running）
- [ ] 支持按时间范围筛选

#### API 示例

```bash
# 查询工作流执行历史
GET /api/v2/workflows/wf-001/runs?status=failed&limit=10

# 响应
{
  "total": 45,
  "runs": [
    {
      "runId": "run-123",
      "status": "failed",
      "startTime": "2025-11-21T10:30:00Z",
      "duration": 2500,
      "totalSteps": 5,
      "completedSteps": 3,
      "failedSteps": 1
    }
  ]
}
```

---

### Story 2.15: 创建工作流类型的测试案例（模式1：引用工作流）

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 测试工程师
我想要 创建引用已有工作流的测试案例
以便于 将复杂的业务流程测试纳入测试案例管理体系
```

#### 验收标准

- [ ] 测试案例创建页面支持选择type="workflow"
- [ ] 提供工作流选择器（下拉列表显示所有可用工作流）
- [ ] 支持配置工作流级别的断言（workflow_success, step_count等）
- [ ] 支持配置超时时间
- [ ] 创建后在测试列表中正确显示为工作流类型
- [ ] API支持创建: POST /api/v2/tests with workflowId

#### 技术要点

- 扩展测试案例创建表单，添加工作流类型选项
- 工作流选择器从 GET /api/v2/workflows 加载数据
- 验证引用的workflowId存在
- 数据库字段：test_cases.workflow_id

---

### Story 2.16: 创建工作流类型的测试案例（模式2：内嵌工作流）

**优先级**: P1
**估算**: M (3天)

#### Story 描述

```
作为 测试工程师
我想要 在测试案例中直接定义简单的工作流
以便于 快速创建多步骤测试而无需管理独立的工作流
```

#### 验收标准

- [ ] 测试案例创建页面支持内嵌工作流定义
- [ ] 提供YAML编辑器用于编写工作流定义
- [ ] 支持语法验证和实时错误提示
- [ ] 支持从模板快速插入常用步骤
- [ ] 创建后工作流定义保存到test_cases.workflow_def
- [ ] API支持创建: POST /api/v2/tests with workflowDef

#### 技术要点

- 集成Monaco Editor（YAML模式）
- YAML语法验证（使用gopkg.in/yaml.v3）
- 步骤模板库（常用步骤片段）
- 数据库字段：test_cases.workflow_def (JSONB)

---

### Story 2.17: 执行工作流测试案例

**优先级**: P0
**估算**: L (4天)

#### Story 描述

```
作为 测试工程师
我想要 执行工作流类型的测试案例
以便于 验证完整的业务流程是否正常工作
```

#### 验收标准

- [ ] 测试列表页的"执行"按钮支持工作流测试
- [ ] UnifiedTestExecutor正确路由到WorkflowExecutor
- [ ] 模式1：加载引用的工作流并执行
- [ ] 模式2：解析内嵌的工作流定义并执行
- [ ] 执行结果保存到test_results表
- [ ] 关联workflowRunId以便查询详细步骤
- [ ] 支持传入变量覆盖

#### 技术要点

- UnifiedTestExecutor.executeWorkflowTest()实现
- 从workflows表加载工作流（模式1）
- 动态解析workflowDef（模式2）
- WorkflowResult → TestResult转换
- 状态映射：success→passed, failed→failed

---

### Story 2.18: 查看工作流测试结果

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 测试工程师
我想要 查看工作流测试的详细执行结果
以便于 了解每个步骤的执行情况和失败原因
```

#### 验收标准

- [ ] 测试结果详情页识别工作流类型
- [ ] 显示工作流执行概览（总步骤、成功、失败、耗时）
- [ ] 显示每个步骤的详细信息（状态、耗时、输入输出）
- [ ] 支持点击步骤查看详细日志
- [ ] 支持查看变量快照
- [ ] 支持导出工作流执行报告
- [ ] 失败步骤高亮显示错误信息

#### UI设计

```
┌─────────────────────────────────────────────────┐
│  测试结果 - 订单完整流程测试                    │
│  状态: ✅ 通过  执行时间: 5分30秒               │
├─────────────────────────────────────────────────┤
│  概览:                                          │
│  总步骤: 5个  ✅ 成功: 5个  ❌ 失败: 0个       │
│                                                 │
│  步骤详情:                                      │
│  ✅ 1. register - 注册用户      (200ms)        │
│     Input: {username: "test_user_123"}          │
│     Output: {userId: 12345}                     │
│  ✅ 2. login - 用户登录         (150ms)        │
│     Output: {token: "eyJ..."}                   │
│  ✅ 3. create-order - 创建订单  (300ms)        │
│     Output: {orderId: 67890}                    │
└─────────────────────────────────────────────────┘
```

#### 技术要点

- 查询workflow_runs和workflow_step_executions表
- 结果页面组件复用workflow执行监控组件
- JSON格式化显示输入输出数据

---

### Story 2.19: 工作流中引用测试案例（模式3）

**优先级**: P1
**估算**: M (3天)

#### Story 描述

```
作为 自动化测试工程师
我想要 在工作流步骤中引用已有的测试案例
以便于 复用现有测试逻辑并组合成复杂流程
```

#### 验收标准

- [ ] 工作流编辑器支持添加type="test-case"步骤
- [ ] 提供测试案例选择器
- [ ] 支持配置input变量映射（传递给测试案例）
- [ ] 支持配置output提取（从测试结果中提取数据）
- [ ] TestCaseAction执行器正确加载并执行测试
- [ ] 测试案例的响应数据可作为后续步骤的输入

#### 工作流YAML示例

```yaml
steps:
  - id: test-user-create
    type: test-case
    testId: "api-user-create"
    input:
      username: "test_${timestamp}"
    output:
      userId: "response.data.id"

  - id: test-user-login
    type: test-case
    testId: "api-user-login"
    dependsOn: [test-user-create]
    input:
      username: "${test-user-create.username}"
```

#### 技术要点

- TestCaseAction实现（Action接口）
- 加载测试案例：testCaseRepo.GetTestCase(testId)
- 变量替换：applyInputVariables()
- 执行测试：executor.ExecuteTest()
- 提取输出：从TestResult.Data映射到步骤输出

---

### Story 2.20: 测试-工作流关联查询

**优先级**: P2
**估算**: S (2天)

#### Story 描述

```
作为 测试负责人
我想要 查询某个工作流被哪些测试案例引用
以便于 评估工作流变更的影响范围
```

#### 验收标准

- [ ] 工作流详情页显示"关联的测试案例"列表
- [ ] API支持查询：GET /api/v2/workflows/:id/test-cases
- [ ] 显示引用此工作流的所有测试案例
- [ ] 支持一键执行所有关联测试
- [ ] 测试案例详情页显示引用的工作流信息
- [ ] 工作流删除前检查是否被测试引用（警告）

#### API示例

```bash
GET /api/v2/workflows/workflow-order-v2.1/test-cases

# 响应
{
  "workflowId": "workflow-order-v2.1",
  "testCases": [
    {
      "testId": "e2e-order-flow",
      "name": "订单完整流程测试",
      "priority": "P0",
      "status": "active"
    }
  ]
}
```

#### 技术要点

- 数据库查询：SELECT * FROM test_cases WHERE workflow_id = ?
- 反向关联查询
- 级联删除保护

---

## Epic 3: Lua脚本支持

**Epic 描述**: 集成Lua脚本引擎，支持编写自定义逻辑、动态数据生成、复杂断言。

**业务价值**: 灵活性提升10倍，支持任意复杂逻辑

**目标用户**: 自动化测试工程师（高级用户）

**发布版本**: v3.0 (Phase 3)

---

### Story 3.1: Lua引擎集成

**优先级**: P0
**估算**: L (4天)

#### Story 描述

```
作为 系统后端
我需要 集成Lua脚本引擎
以便于 执行用户编写的Lua脚本
```

#### 验收标准

- [ ] 集成 `github.com/yuin/gopher-lua`
- [ ] 沙箱环境（禁用`os`、`io`、`debug`模块）
- [ ] 执行超时控制（默认5秒）
- [ ] 内存限制（最大10MB）
- [ ] 错误捕获和日志
- [ ] 单元测试覆盖

#### 技术要点

- 创建独立的Lua VM实例（每次执行）
- 禁用危险模块：`L.SetGlobal("os", lua.LNil)`
- 使用Context控制超时
- panic恢复机制

---

### Story 3.2: 预定义函数库

**优先级**: P0
**估算**: L (4天)

#### Story 描述

```
作为 自动化测试工程师
我想要 使用预定义的函数库
以便于 快速编写脚本，无需从零开始
```

#### 验收标准

- [ ] HTTP函数：`httpRequest(config)`
- [ ] JSON函数：`json.decode(str)`, `json.encode(obj)`
- [ ] 日志函数：`log.info()`, `log.error()`
- [ ] 断言函数：`assert(condition, message)`
- [ ] 工具函数：`sleep(ms)`, `uuid()`, `timestamp()`
- [ ] 字符串函数：`string.trim()`, `string.split()`
- [ ] 数学函数：`math.random()`, `math.round()`
- [ ] 函数文档（Markdown）

#### 函数示例

```lua
-- HTTP请求
local response = httpRequest({
    method = "GET",
    url = "https://api.example.com/users",
    headers = {Authorization = "Bearer " .. token}
})

-- JSON解析
local data = json.decode(response.body)

-- 日志
log.info("Found " .. #data .. " users")

-- 断言
assert(response.statusCode == 200, "Status code should be 200")
```

#### 技术要点

- 注册Go函数到Lua：`L.SetGlobal("httpRequest", L.NewFunction(luaHTTPRequest))`
- Go与Lua数据类型转换

---

### Story 3.3: 脚本步骤类型

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 自动化测试工程师
我想要 在工作流中执行Lua脚本步骤
以便于 实现复杂逻辑
```

#### 验收标准

- [ ] 工作流支持 `type: lua-script`
- [ ] 脚本内容字段：`script`
- [ ] 上下文注入（工作流变量）
- [ ] 脚本返回值提取（output）
- [ ] 错误处理（onError）

#### 工作流示例

```yaml
steps:
  - id: generate-data
    type: lua-script
    script: |
      local users = {}
      for i = 1, 10 do
        table.insert(users, {
          username = "user_" .. i,
          email = "user" .. i .. "@test.com"
        })
      end
      return users
    output:
      testUsers: "return"

  - id: create-users
    type: http
    input:
      users: "${generate-data.testUsers}"
```

#### 技术要点

- 执行脚本前注入上下文变量
- 获取脚本返回值：`L.Get(-1)`
- 将返回值转换为Go类型

---

### Story 3.4: 脚本编辑器

**优先级**: P1
**估算**: M (3天)

#### Story 描述

```
作为 自动化测试工程师
我想要 一个专业的脚本编辑器
以便于 编写和调试Lua脚本
```

#### 验收标准

- [ ] 集成Monaco Editor
- [ ] Lua语法高亮
- [ ] 代码补全（预定义函数）
- [ ] 错误提示（语法错误）
- [ ] 行号显示
- [ ] 快捷键支持（Ctrl+S保存、Ctrl+/注释）

#### UI 设计

```
┌─────────────────────────────────────────┐
│  💻 Lua 脚本编辑器                      │
├─────────────────────────────────────────┤
│  1  function validateOrder(response)    │
│  2      local order = response.data     │
│  3      local total = 0                 │
│  4                                      │
│  5      for _, item in ipairs(...) do   │
│  6          total = total + ...         │
│  7      end                             │
│  8                                      │
│  9      assert(total > 0)               │
│ 10  end                                 │
│                                         │
│  📚 函数库   🐛 调试   ▶️ 运行测试      │
└─────────────────────────────────────────┘
```

---

### Story 3.5: 脚本调试工具

**优先级**: P2
**估算**: M (3天)

#### Story 描述

```
作为 自动化测试工程师
我想要 调试Lua脚本
以便于 快速定位脚本错误
```

#### 验收标准

- [ ] 在线运行脚本（不执行完整工作流）
- [ ] 模拟上下文输入
- [ ] 查看脚本输出
- [ ] 查看日志
- [ ] 显示运行时间和内存占用

#### UI 设计

```
┌─────────────────────────────────────────┐
│  🐛 脚本调试器                          │
├─────────────────────────────────────────┤
│  输入上下文 (JSON):                     │
│  {                                      │
│    "userId": "123",                     │
│    "token": "abc..."                    │
│  }                                      │
│                                         │
│  [▶️ 运行]                               │
│                                         │
│  输出:                                  │
│  ✅ 执行成功 (120ms, 2MB)               │
│  返回值: [...]                          │
│                                         │
│  日志:                                  │
│  [INFO] Found 10 users                  │
└─────────────────────────────────────────┘
```

---

### Story 3.6: 脚本安全审计

**优先级**: P0
**估算**: S (2天)

#### Story 描述

```
作为 系统管理员
我需要 审计Lua脚本的安全性
以便于 防止恶意代码执行
```

#### 验收标准

- [ ] 脚本提交时触发安全扫描
- [ ] 检测危险模式（如`os.execute`、`io.open`）
- [ ] 高风险操作需要审批流程
- [ ] 审计日志记录
- [ ] 权限控制（普通用户只能运行预定义脚本）

#### 技术要点

- 正则匹配危险模式
- 黑名单机制
- 审批工作流集成

---

## Epic 4: 模板系统

**Epic 描述**: 提供标准化测试模板库，支持变量替换、模板继承、快速创建。

**业务价值**: 降低测试创建门槛，新人上手时间从3天降至1天

**目标用户**: 所有测试人员（尤其新手）

**发布版本**: v1.0 (Phase 1)

---

### Story 4.1: 模板定义格式

**优先级**: P0
**估算**: S (2天)

#### Story 描述

```
作为 产品设计者
我需要 定义模板的数据格式
以便于 支持变量替换和继承
```

#### 验收标准

- [ ] JSON格式模板定义
- [ ] 必填字段：id, name, variables, content
- [ ] 变量定义：name, type, required, default, description
- [ ] 内容支持测试定义或工作流定义
- [ ] 变量占位符语法：`${variableName}`

#### 模板示例

```json
{
  "id": "restful-crud",
  "name": "RESTful CRUD 模板",
  "category": "API测试",
  "variables": [
    {
      "name": "resource",
      "type": "string",
      "required": true,
      "description": "资源名称（如 users, products）"
    },
    {
      "name": "baseUrl",
      "type": "string",
      "default": "http://localhost:8080/api"
    }
  ],
  "content": {
    "tests": [
      {
        "name": "创建${resource}",
        "type": "http",
        "http": {
          "method": "POST",
          "path": "${baseUrl}/${resource}"
        }
      }
    ]
  }
}
```

---

### Story 4.2: 模板CRUD API

**优先级**: P0
**估算**: S (2天)

#### Story 描述

```
作为 前端开发者
我需要 模板管理API
以便于 实现模板的增删改查
```

#### 验收标准

- [ ] `POST /api/v2/templates` - 创建模板
- [ ] `GET /api/v2/templates` - 列出模板（支持分类、搜索）
- [ ] `GET /api/v2/templates/:id` - 获取模板详情
- [ ] `PUT /api/v2/templates/:id` - 更新模板
- [ ] `DELETE /api/v2/templates/:id` - 删除模板
- [ ] `POST /api/v2/templates/:id/render` - 渲染模板（填充变量）

---

### Story 4.3: 变量替换引擎

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 系统后端
我需要 实现变量替换引擎
以便于 根据用户输入生成最终配置
```

#### 验收标准

- [ ] 解析模板内容，识别`${variableName}`
- [ ] 验证必填变量
- [ ] 应用默认值
- [ ] 执行替换
- [ ] 返回渲染后的JSON
- [ ] 未定义变量报错

#### 技术要点

- 正则表达式匹配：`\$\{(\w+)\}`
- 递归替换（支持嵌套）
- 类型转换（string/number/boolean）

---

### Story 4.4: 官方模板库

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 产品负责人
我需要 提供10+官方模板
以便于 用户开箱即用
```

#### 验收标准

- [ ] 创建10个官方模板：
  1. RESTful CRUD
  2. JWT认证
  3. OAuth认证
  4. 文件上传
  5. 文件下载
  6. 分页查询
  7. 批量操作
  8. WebSocket连接
  9. GraphQL查询
  10. 数据库连接测试
- [ ] 每个模板包含：变量定义、示例、说明文档
- [ ] 标记为官方模板（`is_official: true`）

---

### Story 4.5: 模板市场UI

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 QA测试工程师
我想要 浏览和搜索模板
以便于 找到合适的模板快速创建测试
```

#### 验收标准

- [ ] 模板市场页面
- [ ] 卡片式展示（名称、描述、使用次数、评分）
- [ ] 分类筛选（API测试、性能测试、集成测试）
- [ ] 搜索功能（模糊匹配名称、描述）
- [ ] 排序（最受欢迎、最新、评分最高）
- [ ] 预览模板内容
- [ ] 使用按钮（跳转到变量填写页）

#### UI 设计

```
┌─────────────────────────────────────────────┐
│  🛒 模板市场                                │
├─────────────────────────────────────────────┤
│  [搜索框]  [分类筛选▼]  [排序: 最受欢迎▼]  │
├─────────────────────────────────────────────┤
│  ┌──────────────────┐  ┌──────────────────┐│
│  │ RESTful CRUD     │  │ JWT 认证         ││
│  │ ⭐⭐⭐⭐⭐          │  │ ⭐⭐⭐⭐           ││
│  │ 1,234 使用       │  │ 890 使用         ││
│  │ [预览] [使用]    │  │ [预览] [使用]    ││
│  └──────────────────┘  └──────────────────┘│
└─────────────────────────────────────────────┘
```

---

### Story 4.6: 模板使用流程

**优先级**: P0
**估算**: S (2天)

#### Story 描述

```
作为 QA测试工程师
我想要 通过简单的表单使用模板
以便于 快速创建测试用例
```

#### 验收标准

- [ ] 点击"使用"跳转到变量填写页
- [ ] 表单字段根据模板变量动态生成
- [ ] 必填字段标记（*）
- [ ] 默认值自动填充
- [ ] 字段提示（description）
- [ ] 实时预览生成的配置
- [ ] 提交创建测试

#### UI 设计

```
┌─────────────────────────────────────────┐
│  📝 使用模板: RESTful CRUD              │
├─────────────────────────────────────────┤
│                                         │
│  资源名称 (resource) *                  │
│  ┌───────────────────────────────────┐ │
│  │ users                             │ │
│  └───────────────────────────────────┘ │
│  提示: 资源名称（如 users, products）  │
│                                         │
│  API 基础地址 (baseUrl)                 │
│  ┌───────────────────────────────────┐ │
│  │ http://localhost:8080/api         │ │
│  └───────────────────────────────────┘ │
│                                         │
│  [预览]              [取消]  [创建 →]  │
└─────────────────────────────────────────┘
```

---

### Story 4.7: 模板评分系统

**优先级**: P2
**估算**: S (2天)

#### Story 描述

```
作为 QA测试工程师
我想要 为模板评分
以便于 帮助其他人找到优质模板
```

#### 验收标准

- [ ] 5星评分系统
- [ ] 平均评分显示
- [ ] 评分人数统计
- [ ] 每个用户只能评分一次
- [ ] 更新评分

---

## Epic 5: 前端现代化

**Epic 描述**: 使用Vite + React + TypeScript重构前端，提供现代化的用户体验。

**业务价值**: 页面加载从5秒降至2秒，交互响应 < 100ms

**目标用户**: 所有用户

**发布版本**: v4.0 (Phase 4)

---

### Story 5.1: 项目初始化

**优先级**: P0
**估算**: S (2天)

#### Story 描述

```
作为 前端开发者
我需要 搭建现代化的前端项目
以便于 开始开发
```

#### 验收标准

- [ ] 使用Vite创建项目
- [ ] 配置TypeScript
- [ ] 集成React Router v6
- [ ] 集成Zustand状态管理
- [ ] 配置ESLint + Prettier
- [ ] 配置Ant Design 5
- [ ] 配置构建脚本

---

### Story 5.2: 页面迁移 - 测试列表

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 前端开发者
我需要 用新技术栈重写测试列表页
以便于 提升性能和体验
```

#### 验收标准

- [ ] TypeScript组件
- [ ] 虚拟滚动（支持1000+测试）
- [ ] 搜索和筛选
- [ ] 排序
- [ ] 批量操作
- [ ] 响应式布局

---

### Story 5.3: 工作流可视化编辑器

**优先级**: P1
**估算**: XL (8天)

#### Story 描述

```
作为 自动化测试工程师
我想要 通过拖拽方式编排工作流
以便于 可视化地构建测试流程
```

#### 验收标准

- [ ] 集成React Flow
- [ ] 节点类型：HTTP测试、命令、Lua脚本
- [ ] 拖拽添加节点
- [ ] 连线表示依赖关系
- [ ] 节点配置面板
- [ ] 自动布局
- [ ] 导出为YAML
- [ ] 从YAML导入

#### UI 设计

```
┌─────────────────────────────────────────────┐
│  🔀 工作流编辑器                            │
├─────────────────────────────────────────────┤
│  工具箱          │  画布                    │
│  ┌────────┐     │                          │
│  │ 📡 HTTP │     │   ┌────────────┐         │
│  │ 💻 命令 │     │   │  注册用户  │         │
│  │ 🔧 Lua  │     │   └─────┬──────┘         │
│  └────────┘     │         │                │
│                 │   ┌─────▼──────┐         │
│  属性面板        │   │  用户登录  │         │
│  ┌────────┐     │   └─────┬──────┘         │
│  │ 节点名称│     │         │                │
│  │ [输入框]│     │   ┌─────▼──────┐         │
│  └────────┘     │   │  创建订单  │         │
│                 │   └────────────┘         │
└─────────────────────────────────────────────┘
```

---

### Story 5.4: 测试结果可视化

**优先级**: P1
**估算**: L (5天)

#### Story 描述

```
作为 开发工程师
我想要 可视化的测试结果展示
以便于 快速定位问题
```

#### 验收标准

- [ ] 调用链图（类似Jaeger）
- [ ] 时序图
- [ ] 趋势图（ECharts）
- [ ] 错误详情展开
- [ ] 支持导出图片

---

### Story 5.5: 实时监控（WebSocket）

**优先级**: P2
**估算**: M (3天)

#### Story 描述

```
作为 QA测试工程师
我想要 实时查看测试执行状态
以便于 无需刷新页面
```

#### 验收标准

- [ ] WebSocket连接管理
- [ ] 实时推送测试状态
- [ ] 实时推送日志
- [ ] 断线重连
- [ ] 消息队列（防止丢失）

---

## Epic 6: 脚本管理

**Epic 描述**: 提供Lua脚本的集中管理功能,支持脚本版本控制、分类组织、共享复用、权限管理。

**业务价值**: 将常用脚本沉淀为可复用资产,减少重复开发,提升团队协作效率

**目标用户**: 自动化测试工程师、测试负责人

**发布版本**: v3.0 (Phase 3)

---

### Story 6.1: 脚本CRUD API

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 后端开发者
我需要 实现脚本管理的CRUD API
以便于 前端可以管理脚本生命周期
```

#### 验收标准

- [ ] `POST /api/v2/scripts` - 创建脚本
- [ ] `GET /api/v2/scripts` - 列出脚本（支持分类、搜索、筛选）
- [ ] `GET /api/v2/scripts/:id` - 获取脚本详情
- [ ] `PUT /api/v2/scripts/:id` - 更新脚本
- [ ] `DELETE /api/v2/scripts/:id` - 删除脚本
- [ ] `POST /api/v2/scripts/:id/versions` - 保存新版本
- [ ] `GET /api/v2/scripts/:id/versions` - 获取版本历史
- [ ] `POST /api/v2/scripts/:id/approve` - 审核批准脚本

#### 技术要点

- 脚本内容存储为TEXT字段
- 版本号自动递增
- 软删除机制
- 审核状态机（pending → approved/rejected）

---

### Story 6.2: 脚本库UI

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 测试工程师
我想要 浏览和管理脚本库
以便于 找到可复用的脚本并引用到测试中
```

#### 验收标准

- [ ] 脚本列表页（表格展示）
- [ ] 显示字段：名称、分类、使用次数、状态、创建者、更新时间
- [ ] 搜索功能（按名称、标签）
- [ ] 分类筛选（工具脚本、验证脚本、数据生成等）
- [ ] 状态筛选（待审核、已批准、已拒绝）
- [ ] 排序（最近更新、使用次数、名称）
- [ ] 操作按钮（查看、编辑、删除、复制）

#### UI 设计

```
┌─────────────────────────────────────────────────┐
│  📚 脚本库                    [➕ 新建脚本]      │
├─────────────────────────────────────────────────┤
│  [搜索框]  [分类▼]  [状态▼]  [排序: 最近更新▼] │
├─────────────────────────────────────────────────┤
│  脚本名称              分类        使用次数  状态│
│  📄 生成随机用户       工具脚本    234      ✅   │
│  📄 验证订单金额       验证脚本    156      ✅   │
│  📄 清理测试数据       工具脚本     89      🔒   │
│  📄 批量创建订单       数据生成     45      ⏳   │
└─────────────────────────────────────────────────┘
```

---

### Story 6.3: 脚本编辑器增强

**优先级**: P1
**估算**: M (3天)

#### Story 描述

```
作为 测试工程师
我想要 在脚本编辑器中编写和调试Lua脚本
以便于 快速开发和验证脚本逻辑
```

#### 验收标准

- [ ] 脚本基本信息编辑（名称、分类、标签、描述）
- [ ] 参数定义编辑（参数名、类型、默认值、说明）
- [ ] 可见性设置（公开/团队/私有）
- [ ] 保存版本时添加备注
- [ ] 集成Monaco Editor（已有，复用）
- [ ] 语法高亮和代码补全（已有，复用）
- [ ] 在线测试运行按钮

---

### Story 6.4: 脚本版本管理

**优先级**: P1
**估算**: M (3天)

#### Story 描述

```
作为 测试工程师
我想要 查看脚本的版本历史并回滚
以便于 追溯变更和恢复旧版本
```

#### 验收标准

- [ ] 版本列表展示（版本号、时间、修改者、备注）
- [ ] 当前版本标记
- [ ] 版本对比功能（diff视图）
- [ ] 回滚到指定版本
- [ ] 版本备注编辑
- [ ] 删除历史版本（保留最近10个版本）

#### UI 设计

```
┌─────────────────────────────────────────┐
│  📜 版本历史                            │
├─────────────────────────────────────────┤
│  版本    时间              修改者  备注 │
│  v1.2 ● 2025-11-21 09:15  张三   优化   │
│  v1.1   2025-11-20 15:20  张三   修复   │
│  v1.0   2025-11-20 10:30  张三   创建   │
│                                         │
│  [查看差异] [回滚到此版本]              │
└─────────────────────────────────────────┘
```

---

### Story 6.5: 脚本权限控制

**优先级**: P0
**估算**: S (2天)

#### Story 描述

```
作为 系统管理员
我需要 控制脚本的访问和操作权限
以便于 保护敏感脚本并防止误删
```

#### 验收标准

- [ ] 权限模型实现（创建者、管理员、团队成员、普通用户）
- [ ] 创建者权限：完全控制自己的脚本
- [ ] 管理员权限：管理所有脚本
- [ ] 团队成员权限：查看团队和公开脚本，不能编辑/删除
- [ ] 普通用户权限：仅查看公开脚本
- [ ] 权限检查API中间件
- [ ] 前端按钮根据权限显示/隐藏

#### 权限矩阵

| 角色 | 创建 | 查看 | 编辑 | 删除 | 审核 |
|------|------|------|------|------|------|
| **创建者** | ✅ | ✅ | ✅ | ✅ | - |
| **管理员** | ✅ | ✅ | ✅ | ✅ | ✅ |
| **团队成员** | ✅ | ✅(团队/公开) | ❌ | ❌ | - |
| **普通用户** | ✅ | ✅(公开) | ❌ | ❌ | - |

---

### Story 6.6: 脚本安全审核流程

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 系统管理员
我需要 审核脚本的安全性
以便于 防止恶意代码执行
```

#### 验收标准

- [ ] 脚本提交时自动检测危险模式
- [ ] 危险模式库（os.execute、io.open、loadfile等）
- [ ] 检测到危险代码时自动标记为"待审核"
- [ ] 安全的脚本自动批准
- [ ] 管理员审核界面（批准/拒绝）
- [ ] 审核历史记录
- [ ] 审核拒绝时添加原因

#### 审核流程

```
创建脚本
   ↓
自动检测危险代码
   ↓
是否包含敏感操作？
   ├─ 否 → 自动批准 → 可使用
   └─ 是 → 待审核 → 管理员审核
                      ├─ 批准 → 可使用
                      └─ 拒绝 → 禁用
```

---

### Story 6.7: 脚本使用统计

**优先级**: P2
**估算**: S (2天)

#### Story 描述

```
作为 测试负责人
我想要 查看脚本的使用统计
以便于 了解哪些脚本最有价值
```

#### 验收标准

- [ ] 记录脚本引用次数（被多少测试/工作流引用）
- [ ] 记录脚本执行次数
- [ ] 脚本详情页显示使用统计
- [ ] 脚本列表页按使用次数排序
- [ ] 热门脚本Top 10榜单

---

## Epic 7: 模板管理增强

**Epic 描述**: 在基础模板功能上增强，提供完整的模板生命周期管理，包括版本控制、分享、评价、数据分析。

**业务价值**: 根据使用反馈改进模板，形成模板生态，持续优化

**目标用户**: 所有测试人员、测试负责人

**发布版本**: v3.5 (Phase 3.5)

---

### Story 7.1: 模板版本管理

**优先级**: P1
**估算**: M (3天)

#### Story 描述

```
作为 模板创建者
我想要 管理模板的版本历史
以便于 追溯变更和回滚到旧版本
```

#### 验收标准

- [ ] 模板保存时创建新版本
- [ ] 版本号自动递增（v1.0, v1.1, v2.0）
- [ ] 版本列表展示
- [ ] 版本对比功能（diff）
- [ ] 回滚到历史版本
- [ ] 版本备注编辑

---

### Story 7.2: 模板Fork功能

**优先级**: P1
**估算**: S (2天)

#### Story 描述

```
作为 测试工程师
我想要 Fork一个模板并修改
以便于 基于现有模板创建自定义版本
```

#### 验收标准

- [ ] 模板详情页"Fork"按钮
- [ ] Fork后创建新模板（复制内容）
- [ ] 新模板标记来源（forked from: xxx）
- [ ] Fork计数统计
- [ ] Fork关系图谱（可选，Phase 4）

---

### Story 7.3: 模板评价系统

**优先级**: P1
**估算**: M (3天)

#### Story 描述

```
作为 测试工程师
我想要 为模板评分和评论
以便于 帮助其他人选择优质模板
```

#### 验收标准

- [ ] 5星评分系统
- [ ] 评分维度：整体、易用性、文档完整度、功能覆盖度
- [ ] 文字评论
- [ ] 评论点赞/踩
- [ ] 评论回复
- [ ] 平均评分计算和显示
- [ ] 评分人数统计
- [ ] 每个用户只能评分一次（可修改）

---

### Story 7.4: 模板使用分析

**优先级**: P2
**估算**: M (3天)

#### Story 描述

```
作为 测试负责人
我想要 查看模板的使用分析数据
以便于 了解模板的受欢迎程度和成功率
```

#### 验收标准

- [ ] 记录模板使用次数
- [ ] 记录基于模板创建的测试成功率
- [ ] 使用趋势图（过去30天）
- [ ] 成功率统计
- [ ] 模板分析仪表盘
- [ ] Top 10 最受欢迎模板

#### UI 设计

```
┌─────────────────────────────────────────────────┐
│  📊 模板分析仪表盘                              │
├─────────────────────────────────────────────────┤
│  Top 10 最受欢迎模板                            │
│  1. RESTful CRUD        1,234次  ⭐4.8         │
│  2. JWT认证              890次   ⭐4.7         │
│  3. 文件上传             567次   ⭐4.6         │
│  ...                                            │
│                                                 │
│  使用趋势 [折线图]                              │
│  分类分布 [饼图]                                │
│  成功率统计 [条形图]                            │
└─────────────────────────────────────────────────┘
```

---

### Story 7.5: 模板导入导出

**优先级**: P2
**估算**: S (2天)

#### Story 描述

```
作为 测试工程师
我想要 导入和导出模板
以便于 在不同环境间迁移模板
```

#### 验收标准

- [ ] 导出模板为JSON文件
- [ ] 从JSON文件导入模板
- [ ] 导入时验证JSON格式
- [ ] 导入时处理ID冲突（重命名）
- [ ] 批量导出多个模板

---

## Epic 8: 数据库表格管理

**Epic 描述**: 提供可视化的数据库表格管理界面，支持数据库连接配置、表结构浏览、数据查询、数据操作，用于数据驱动测试和测试数据准备。

**业务价值**: 直接在界面中准备测试数据、验证数据库状态、快速排查问题

**目标用户**: 测试工程师、数据库管理员

**发布版本**: v3.5 (Phase 3.5)

---

### Story 8.1: 数据库连接管理

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 测试工程师
我想要 配置和管理数据库连接
以便于 连接到测试数据库进行操作
```

#### 验收标准

- [ ] 连接CRUD API
- [ ] 支持MySQL、PostgreSQL、SQLite
- [ ] 连接配置：主机、端口、数据库、用户名、密码
- [ ] 连接测试功能
- [ ] 只读模式开关
- [ ] SSL连接支持
- [ ] 连接超时配置
- [ ] 连接状态显示（在线/离线）

#### UI 设计

```
┌─────────────────────────────────────────┐
│  ➕ 新建数据库连接                      │
├─────────────────────────────────────────┤
│  连接名称: [测试数据库              ]   │
│  数据库类型: [MySQL ▼]                 │
│                                         │
│  主机: [localhost                   ]   │
│  端口: [3306                        ]   │
│  数据库: [test_db                   ]   │
│  用户名: [root                      ]   │
│  密码: [••••••••                    ]   │
│                                         │
│  高级选项:                              │
│  □ 只读模式                             │
│  □ SSL连接                              │
│  连接超时: [30] 秒                      │
│                                         │
│  [测试连接]        [取消]  [保存]       │
└─────────────────────────────────────────┘
```

---

### Story 8.2: 表结构浏览

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 测试工程师
我想要 浏览数据库表结构
以便于 了解表字段和索引信息
```

#### 验收标准

- [ ] 连接后显示表列表（左侧树形结构）
- [ ] 表分组（业务表、系统表）
- [ ] 点击表显示字段信息（右侧详情）
- [ ] 字段信息：名称、类型、NULL、键、默认值
- [ ] 索引信息：索引名、字段、类型（主键/唯一/普通）
- [ ] 外键关系
- [ ] 表统计信息（行数、大小）
- [ ] 刷新表结构

#### UI 设计

```
┌─────────────────────────────────────────────────┐
│  🗄️ 数据库: test_db                             │
├──────────────┬──────────────────────────────────┤
│  表列表      │  表详情 - users                  │
│              │                                  │
│  ▼ 业务表    │  字段信息:                       │
│   📊 users   │  名称      类型     NULL  键     │
│   📊 orders  │  id        INT      NO    PRI    │
│   📊 products│  username  VARCHAR  NO    UNI    │
│              │  email     VARCHAR  NO    UNI    │
│  ▼ 系统表    │  password  VARCHAR  NO           │
│   📊 logs    │  created_at DATETIME NO          │
│              │                                  │
│              │  索引:                           │
│              │  idx_username (username)         │
│              │  idx_email (email)               │
│              │                                  │
│              │  统计: 1,234 行                  │
└──────────────┴──────────────────────────────────┘
```

---

### Story 8.3: SQL查询编辑器

**优先级**: P0
**估算**: L (4天)

#### Story 描述

```
作为 测试工程师
我想要 执行SQL查询
以便于 查看和分析数据
```

#### 验收标准

- [ ] SQL编辑器（Monaco Editor，SQL模式）
- [ ] 语法高亮
- [ ] 自动补全（表名、字段名）
- [ ] 执行按钮
- [ ] 查询结果表格展示
- [ ] 分页显示（每页100行）
- [ ] 排序功能
- [ ] 导出查询结果（CSV、Excel）
- [ ] 复制查询结果
- [ ] 显示执行时间和行数
- [ ] 查询历史记录（最近20条）

#### UI 设计

```
┌─────────────────────────────────────────────────┐
│  💻 SQL 编辑器                                  │
├─────────────────────────────────────────────────┤
│  1  SELECT * FROM users                         │
│  2  WHERE created_at > '2025-11-01'             │
│  3  ORDER BY created_at DESC                    │
│  4  LIMIT 100;                                  │
│                                                 │
│  [▶️ 执行] [💾 保存查询] [📜 历史] [📚 模板]    │
├─────────────────────────────────────────────────┤
│  查询结果 (100 行, 执行时间: 45ms)              │
│  ┌────┬──────────┬──────────────┬───────────┐  │
│  │ id │ username │ email        │ created_at│  │
│  ├────┼──────────┼──────────────┼───────────┤  │
│  │ 1  │ user1    │ u1@test.com  │ 2025-11.. │  │
│  │ 2  │ user2    │ u2@test.com  │ 2025-11.. │  │
│  │... │ ...      │ ...          │ ...       │  │
│  └────┴──────────┴──────────────┴───────────┘  │
│                                                 │
│  [导出CSV] [导出Excel] [复制]                  │
└─────────────────────────────────────────────────┘
```

---

### Story 8.4: 数据CRUD操作

**优先级**: P1
**估算**: M (3天)

#### Story 描述

```
作为 测试工程师
我想要 在界面中编辑数据
以便于 准备测试数据
```

#### 验收标准

- [ ] 查询结果表格支持行选择
- [ ] 双击行打开编辑对话框
- [ ] 编辑对话框显示所有字段
- [ ] 只读字段标记（如auto_increment ID）
- [ ] 保存更新到数据库
- [ ] 新建行按钮
- [ ] 删除行按钮（需二次确认）
- [ ] 批量删除（选中多行）
- [ ] 操作成功/失败提示

---

### Story 8.5: 批量数据Mock生成

**优先级**: P1
**估算**: L (4天)

#### Story 描述

```
作为 测试工程师
我想要 批量生成测试数据
以便于 快速准备大量测试数据
```

#### 验收标准

- [ ] Mock生成对话框
- [ ] 选择目标表
- [ ] 设置生成数量
- [ ] 字段映射配置：
  - 随机字符串（长度范围）
  - 随机数字（范围）
  - 随机邮箱
  - 随机日期（范围）
  - 固定值
  - 自增序列
- [ ] 预览生成数据（前10条）
- [ ] 执行生成
- [ ] 跳过重复记录选项
- [ ] 使用事务选项

#### UI 设计

```
┌─────────────────────────────────────────────────┐
│  🎲 批量生成测试数据                            │
├─────────────────────────────────────────────────┤
│  目标表: [users ▼]                             │
│  生成数量: [100                              ]  │
│                                                 │
│  字段映射:                                      │
│  username: [随机字符串(8-16位) ▼]              │
│  email:    [随机邮箱               ▼]          │
│  password: [固定值: 123456         ▼]          │
│  age:      [随机数(18-60)          ▼]          │
│                                                 │
│  高级选项:                                      │
│  □ 跳过重复记录                                 │
│  □ 使用事务                                     │
│                                                 │
│  [预览] [生成]                                  │
└─────────────────────────────────────────────────┘
```

---

### Story 8.6: 查询模板管理

**优先级**: P2
**估算**: S (2天)

#### Story 描述

```
作为 测试工程师
我想要 保存常用查询为模板
以便于 快速执行重复查询
```

#### 验收标准

- [ ] 保存查询为模板
- [ ] 模板CRUD
- [ ] 模板列表展示
- [ ] 使用模板（一键加载到编辑器）
- [ ] 模板分类
- [ ] 模板搜索

---

### Story 8.7: 数据库安全控制

**优先级**: P0
**估算**: M (3天)

#### Story 描述

```
作为 系统管理员
我需要 控制数据库操作的安全性
以便于 防止误删生产数据
```

#### 验收标准

- [ ] 只读模式强制执行（拒绝INSERT/UPDATE/DELETE/DROP）
- [ ] 危险操作二次确认（DELETE、UPDATE、DROP、TRUNCATE）
- [ ] 操作审计日志（记录所有SQL）
- [ ] 审计日志查询界面
- [ ] 权限控制（基于角色）
- [ ] SQL注入防护（参数化查询）

---

### Story 8.8: 工作流数据库集成

**优先级**: P1
**估算**: M (3天)

#### Story 描述

```
作为 自动化测试工程师
我想要 在工作流中使用数据库步骤
以便于 准备测试数据、验证数据库状态
```

#### 验收标准

- [ ] 工作流支持 `type: database` 步骤
- [ ] 支持操作类型：query、insert、update、delete
- [ ] 支持参数化查询
- [ ] 支持结果断言
- [ ] 支持输出提取（如last_insert_id）
- [ ] 支持 `runOnFailure` 清理数据

#### 工作流示例

```yaml
workflow:
  steps:
    - id: prepare-data
      type: database
      database: test_db
      operation: insert
      table: users
      data:
        username: "test_user_${timestamp}"
      output:
        userId: "last_insert_id"

    - id: verify-db
      type: database
      database: test_db
      operation: query
      sql: "SELECT * FROM users WHERE id = ?"
      params: ["${prepare-data.userId}"]
      assertions:
        - field: username
          expected: "test_user_${timestamp}"

    - id: cleanup
      type: database
      database: test_db
      operation: delete
      table: users
      where: "id = ?"
      params: ["${prepare-data.userId}"]
      runOnFailure: true
```

---

## 附录: Story 地图

### Story 地图（User Story Mapping）

```
Epic 层:
┌──────────┬──────────┬──────────┬──────────┬──────────┬──────────┬──────────┬──────────┐
│ 批量导入 │ 工作流   │ Lua脚本  │ 模板系统 │ 前端现代 │ 脚本管理 │ 模板增强 │ 数据库   │
└──────────┴──────────┴──────────┴──────────┴──────────┴──────────┴──────────┴──────────┘

Feature 层:
┌──────────┬──────────┬──────────┬──────────┬──────────┬──────────┬──────────┬──────────┐
│ CSV导入  │ YAML定义 │ Lua引擎  │ 模板定义 │ Vite搭建 │ 脚本CRUD │ 版本管理 │ 连接管理 │
│ Excel导入│ 依赖解析 │ 函数库   │ 变量替换 │ 页面迁移 │ 脚本库UI │ Fork功能 │ 表结构   │
│ JSON导入 │ 变量传递 │ 脚本步骤 │ 官方模板 │ 可视化   │ 编辑器   │ 评价系统 │ SQL编辑器│
│ 导入策略 │ 条件执行 │ 编辑器   │ 模板市场 │ 实时监控 │ 版本管理 │ 使用分析 │ 数据CRUD │
│ 进度显示 │ 错误处理 │ 调试工具 │ 评分系统 │          │ 权限控制 │ 导入导出 │ Mock生成 │
│ 历史查询 │ 执行引擎 │ 安全审计 │          │          │ 安全审核 │          │ 查询模板 │
│          │ API      │          │          │          │ 使用统计 │          │ 安全控制 │
│          │ UI页面   │          │          │          │          │          │ 工作流集成│
│          │ 数据追踪 │          │          │          │          │          │          │
│          │ 变量监控 │          │          │          │          │          │          │
│          │ 日志收集 │          │          │          │          │          │          │
│          │ WebSocket│          │          │          │          │          │          │
│          │ 历史查询 │          │          │          │          │          │          │
└──────────┴──────────┴──────────┴──────────┴──────────┴──────────┴──────────┴──────────┘

优先级标记:
🔴 P0 - 必须有（MVP）
🟡 P1 - 应该有
🟢 P2 - 可以有
```

### 发布路线图

```
v1.0 (Phase 1) - 2025-04
├─ 🔴 Epic 1: 批量导入 (Story 1.1-1.6)
└─ 🔴 Epic 4: 模板系统 (Story 4.1-4.6)

v2.0 (Phase 2) - 2025-06
└─ 🔴 Epic 2: 工作流 (Story 2.1-2.14)

v3.0 (Phase 3) - 2025-08
├─ 🟡 Epic 3: Lua脚本 (Story 3.1-3.6)
└─ 🟡 Epic 6: 脚本管理 (Story 6.1-6.7)

v3.5 (Phase 3.5) - 2025-09
├─ 🟡 Epic 7: 模板管理增强 (Story 7.1-7.5)
└─ 🟡 Epic 8: 数据库表格管理 (Story 8.1-8.8)

v4.0 (Phase 4) - 2025-10
└─ 🟡 Epic 5: 前端现代化 (Story 5.1-5.5)
```

---

## 总结

本文档共定义了 **8个Epic**，**58个User Story**：

| Epic | Story数量 | 总估算（人天） | 优先级分布 |
|------|----------|---------------|-----------|
| Epic 1: 批量导入 | 6 | 14 | P0: 4, P1: 1, P2: 1 |
| Epic 2: 工作流 | 20 | 61 | P0: 13, P1: 6, P2: 1 |
| Epic 3: Lua脚本 | 6 | 20 | P0: 3, P1: 2, P2: 1 |
| Epic 4: 模板系统 | 7 | 17 | P0: 6, P2: 1 |
| Epic 5: 前端现代化 | 5 | 21 | P0: 2, P1: 2, P2: 1 |
| Epic 6: 脚本管理 | 7 | 19 | P0: 4, P1: 2, P2: 1 |
| Epic 7: 模板管理增强 | 5 | 13 | P1: 3, P2: 2 |
| Epic 8: 数据库表格管理 | 8 | 25 | P0: 4, P1: 4 |
| **总计** | **64** | **190** | **P0: 36, P1: 20, P2: 8** |

**预计总工期**: 约 **173人天**（按2人团队，约4-5个月）

---

**文档结束**

**评审与更新**:
- [ ] 产品负责人评审
- [ ] 开发团队评估
- [ ] 测试团队审核
- [ ] 定期更新（每Sprint）
